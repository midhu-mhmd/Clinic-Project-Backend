import Plan from "../models/planModel.js";

/**
 * PlanService
 * Encapsulates business logic for Subscription Tiers.
 * Performance optimized using .lean() for read-heavy operations.
 */
class PlanService {
  /**
   * PUBLIC: Retrieve all active plans for the Pricing Page.
   * Utilizes the custom static method defined in the Plan model.
   */
  async getActivePlans() {
    // getPublicTiers() uses .lean() internally for 5x faster execution
    return await Plan.getPublicTiers();
  }

  /**
   * ADMIN: Retrieve every plan (including archived/inactive ones).
   * Useful for internal dashboard management.
   */
  async getAllPlans() {
    return await Plan.find()
      .sort({ tierLevel: 1 })
      .lean();
  }

  /**
   * SYSTEM: Find a specific plan by ID.
   * Standard lookup for tenant validation.
   */
  async getPlanById(planId) {
    const plan = await Plan.findById(planId).lean();
    if (!plan) {
      throw new Error("Specified subscription plan not found.");
    }
    return plan;
  }

  /**
   * SYSTEM: Find a plan by its URL slug.
   * Used when users select a plan from a marketing URL.
   */
  async getPlanBySlug(slug) {
    return await Plan.findOne({ slug, isActive: true }).lean();
  }

  /**
   * ADMIN: Create a new subscription tier.
   * The 'slug' is automatically generated by the model middleware.
   */
  async createPlan(planData) {
    // Mongoose 'unique' index handles the name collision, 
    // but explicit checks provide cleaner error messages.
    const existing = await Plan.findOne({ name: planData.name }).lean();
    if (existing) {
      throw new Error(`Conflict: A plan named "${planData.name}" already exists.`);
    }

    return await Plan.create(planData);
  }

  /**
   * ADMIN: Update plan limits or pricing.
   * 'runValidators: true' ensures the new data matches our Schema rules.
   */
  async updatePlan(id, updateData) {
    const updatedPlan = await Plan.findByIdAndUpdate(id, updateData, {
      new: true,
      runValidators: true,
    });

    if (!updatedPlan) {
      throw new Error("Update failed: Plan not found.");
    }

    return updatedPlan;
  }

  /**
   * INTERNAL: Limit Enforcement.
   * Checks if a tenant has exceeded their allowed quota.
   * * @param {string} planId - The ID of the tenant's current plan
   * @param {string} limitKey - The key to check (e.g., 'maxDoctors')
   * @param {number} currentCount - The current usage count in the system
   */
  async checkLimit(planId, limitKey, currentCount) {
    // Here we use the instance method checkLimit from our model
    // Note: We need the full Mongoose document (not .lean()) to use instance methods
    const plan = await Plan.findById(planId);
    
    if (!plan) return false;

    return plan.checkLimit(limitKey, currentCount);
  }

  /**
   * ADMIN: Archive a plan.
   * We avoid hard deletes to maintain database integrity for existing subscribers.
   */
  async archivePlan(id) {
    return await this.updatePlan(id, { isActive: false });
  }
}

// Export as a singleton instance
export default new PlanService();